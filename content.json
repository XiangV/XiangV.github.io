{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"关于","text":"** 向玮 ** 邮箱: xiangweibit@126.com QQ: 450220840 目前在一个广告团队做基础架构存储中间件。专注于存储和后端技术。喜欢尝试一些新鲜的东西。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"C++防坑（一）","text":"引言最近项目开发中遇到一些的小细节。很多时候我们明白导致问题的原理，但是在开发中还是会不小心犯错。这里列一下最近自己遇到的和看到的组内发现的错误。 引用失效在一个模块中使用了vector来模拟队列，模块内一个线程以一定的频率从begin向end扫描，以处理那些达到条件的元素。处理的时候由于首先要判断条件是否满足，于是开发的时候手残的使用了引用。伪代码如下： 123456789101112mutex.lock();for (size_t i = 0; i &lt; vec.size(); ++i) { Element &amp;ele = vec[i]; mutex.unlock(); bool handled = CheckShouldHandle(ele); // 调用外部模块去检查 mutex.lock(); if (handled) { Handle(ele); vec.erase(vec.begin() + i); }}mutex.unlock(); 而调用该模块的地方会有很多，其他模块会将element添加到vector中。基本如下： 12345void Add(const Tlement &amp;ele) { mutex.lock(); vec.push_back(ele); mutex.unlock();} 这就是产生问题的地方。调用外部模块时解开了锁，Add调用push_back，我们知道vector在capcity满了之后重新分配，于是原来的引用就失效了。 这里实际上还有另一个问题，算法复杂度会在erase中间元素时由于移动后续元素成为O(n2)。 越界实际上这个错误大家说了太多了，但是还是不小心就会中招。 我们的一个服务使用是由两个团队开发的：算法策略团队和架构团队。 其中一段代码大概是这样写的： 1234567std::vector&lt;Element&gt; items = Retrive();int start_index = -1;...auto ele = items[start_index]; 策略团队经过各种计算选择来确定start_index。但是实际上计算过程某些分支没有给start_index赋值, 最后使用start_index的默认值-1，于是core了。 shared_ptr错误使用简单来说：shared_ptr保存的pointer在多线程下的安全性与shared_ptr没有关系 shared_ptr多线程的安全性要靠atomic_load, atomic_store来保证 raw pointer自己保证各种成员调用的安全性 以上","link":"/2018/05/05/cpp-mind/"},{"title":"Rust语言","text":"Rust 初识初次知道rust-lang要从PingCap开始，PingCap开源的TiKV使用了rust作为开发语言，底层是RocksDB，使用rust ffi调用RocksDB的接口。所以就顺着去了解了一下Rust语言。 看了看Rust的语言特性，确实比较吸引人：所有权系统、泛型、trait、闭包、并发，包括了一个现代语言应该具备的所有特性。 语言特性所有权系统Rust主打的特性是并发内存安全，为了避免c/c++中不安全的内存操作（空悬指针、内存泄漏）创建了所有权系统。所有权系统保证同一时刻不会有多个write，或者write+read，每一时刻数据只有一个owner。 rust编译器在编译阶段就能找出所有不符合rust标准的使用方式，从而避免运行期的不安全。也正是编译期的严格检查，让初学者在编译阶段比较头疼，熟悉之后，使用rust的方式去思考和coding可以避免一些常见的编译问题。 也正是编译期的严格检查，只要编译完成，二进制基本可以无内存问题的安全运行。 所有权系统实际上管理的是堆上内存，指向堆上内存的指针的owner问题。 rust默认声明的变量不可变，这个原则的基础是：多线程下read是安全的。如果变量可变，需要使用mut关键字。 这种所有权系统在参数传递是”复制”时会与c/c++编程经验不一样，比如： 12345678910fn just_print(source: String) { println!(\"{}\", source);}fn main() { // \"Rust-lang is pretty goog\" 是 `static &amp;str // 调用 to_string() 方法复制到堆上 let a = \"Rust-lang is pretty good\".to_string(); just_print(a); println!(\"{}\", a)} 这样是编译通过不了的，报错如下： 因为调用just_print时a的所有权被move到参数中去了，在main中剩下的是一个无效的变量。修正方式是just_print参数修改为source: &amp;String 泛型(generic types)和traitrust支持泛型，这个与c++中的模板类似，泛型参数代表了满足某种trait的类型。 trait实际与java中的interface类似，定义了某些行为。在泛型中，通常需要指定泛型参数满足那些trait，因为你的泛型对象、泛型函数中一定是使用泛型参数对象的一些通用行为的。 123fn template_example&lt;T: Clone + Debug&gt;(p1: &amp;T) { println(\"{:?}\", p1);} 比如上面的例子定义了一个泛型函数，泛型参数T需要实现了Clone和Debug两个trait。 闭包闭包实际上在很多语言中有实现，c++语言从c++11开始支持lambda。rust中的闭包定义如下： 12move |p1: Type1, p2: Type2,...| -&gt; ReturnType {} 闭包可以捕获上下文环境中的自由变量，move指定将捕获的自由变量所有权转移到闭包内。 并发rust中实现并发非常简单 12use std::thread;thread::Spawn(||{}) 引入std::thread，调用其spawn就创建出一个线程。并发的安全性由两个trait：Send Sync 实现了Send就可以安全的在线程间传递，实现了Sync就可以安全的在线程间传递不可变借用。 总结这里非常简单的介绍了Rust中一些特性，实际使用中还有很多细节，还有很多高级特性没有介绍（macro，unsafe）。总体来说rust还是很吸引人的，以后找些事情用rust实现尝试一下。","link":"/2020/05/10/rust-lang/"}],"tags":[{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"rust-lang","slug":"rust-lang","link":"/tags/rust-lang/"}],"categories":[{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]}